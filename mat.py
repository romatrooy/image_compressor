import math


"""
Радиоактивное вещество наблюдалось в течение 2608 равных интервалов времени (по 7.5 сек.).
 Для каждого из этих интервалов регистрировалось число частиц, попавших в счетчик. В таблице 1 приведены числа νj интервалов времени,
   в течение которых в счетчик попало ровно j частиц:

Таблица 1

 jνj05712032383352545325408627371398459271016

Необходимо c помощью критерия хи-квадрат проверить гипотезу о распределении числа частиц, попавших в счетчик, 
по закону Пуассона с параметром λ=3.87.  Уровень значимости для проверки гипотезы взять равным 0.05

 

Объем исследуемой выборки равен...
 """
# p = []
# # Значение λ
# lambda_val = 3.87

# # Расчет P(ξ = 5)
# for _ in range(11):
#     p.append((lambda_val**_ * math.exp(-lambda_val)) / math.factorial(_))

# print(p)

# # Эмпирические частоты (νj)
# nu = [57, 203, 383, 525, 532, 408, 273, 139, 45, 27, 16]



# # Объем выборки
# n = 2608

# # Вычисление статистики χ^2
# chi_squared = sum(((nu[j] - n * p[j]) ** 2) / (n * p[j]) for j in range(len(nu)))

# print(chi_squared)

# import matplotlib.pyplot as plt

# # Данные из таблицы
# x = [20, 19, 28, 26, 23, 21, 24, 26, 28, 25, 25, 22, 18, 26, 17, 30, 19, 25, 29, 27]
# y = [64, 65, 69, 69, 66, 65, 67, 67, 70, 68, 67, 66, 63, 68, 62, 70, 64, 68, 69, 68]

# # Построение поля корреляции
# plt.scatter(x, y, color='blue', marker='o')
# plt.title("Корреляция между степенью деформации (x) и твердостью (y)")
# plt.xlabel("Степень деформации x (%)")
# plt.ylabel("Твердость y (HRC)")
# plt.grid(True)
# plt.show()


"""
Задача. В таблице 1 приведены значения твердости состаренных металлических образцов сплава
 АД31 АО «Русал» y,HRC и степень их деформации x,%. Определить уравнение парной линейной регрессии и 
 его адекватность экспериментальным данным.

Таблица 1

x,%	20	19	28	26	23	21	24	26	28	25	25	22	18	26	17	30	19	25	29	27
y,HRC	64	65	69	69	66	65	67	67	70	68	67	66	63	68	62	70	64	68	69	68
 

Объем экспериментальной выборки n равен...
"""

import numpy as np

# Данные
x = [20, 19, 28, 26, 23, 21, 24, 26, 28, 25, 25, 22, 18, 26, 17, 30, 19, 25, 29, 27]
y = [64, 65, 69, 69, 66, 65, 67, 67, 70, 68, 67, 66, 63, 68, 62, 70, 64, 68, 69, 68]

# Вычисляем средние значения
x_mean = np.mean(x)
y_mean = np.mean(y)

# Выводим результаты
print(f"Среднее значение x: {x_mean:.2f}")
print(f"Среднее значение y: {y_mean:.2f}")

# Вычисление b1
numerator = np.sum((np.array(x) - x_mean) * (np.array(y) - y_mean))
denominator = np.sum((np.array(x) - x_mean) ** 2)
b1 = numerator / denominator

# Вычисление b0
b0 = y_mean - b1 * x_mean

# Выводим результаты
print(f"b1 = {b1:.2f}")
print(f"b0 = {b0:.2f}")

# Вычисляем предсказанные значения y (yi~) для каждого x
y_pred = b0 + np.array(x) * b1

# Сумма квадратов отклонений, объясняемых моделью (Q1)
Q1 = np.sum((y_pred - y_mean) ** 2)

# Сумма квадратов отклонений ошибки (Q2)
Q2 = np.sum((y - y_pred) ** 2)

# Выводим результаты
print(f"Q1 = {Q1:.2f}")
print(f"Q2 = {Q2:.2f}")

from scipy.stats import f

# Параметры для вычисления F-критерия
alpha = 0.05
k1 = 1   # m - 1
k2 = 18  # n - 2

# Критическое значение F
F_cr = f.ppf(1 - alpha, k1, k2)

print(f"Fкр = {F_cr:.2f}")

#Объём вборки n
n = 20 

# Вычисление статистики F
F = Q1 / Q2 * (n - 2)

print(f"F = {F:.2f}")
